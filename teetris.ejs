<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
    </head>
    <body>
        <canvas id="canvas">
        </canvas>
        <canvas id="nextpiece"></canvas>
        <script>
            const pieces = [
                { shape: [-1,0,0,0,1,0,2,0], color: 'cyan', pos:{x:5,y:-5}},
                { shape: [-1,-1,0,-1,0,0,0,1], color: 'purple', pos:{x:5,y:-5}},
                { shape: [-1,1,0,1,0,0,0,-1], color: 'pink', pos:{x:5,y:-5}},
                { shape: [1,1,0,1,1,0,0,0], color: 'blue', pos:{x:5,y:-5}},
                { shape: [-1,0,0,0,0,1,1,1], color: 'green', pos:{x:5,y:-5}},
                { shape: [1,0,0,0,0,1,-1,1], color: 'red', pos:{x:5,y:-5}}
            ]
            const pwidth = 20
            const cwid = 10
            const chei = 20
            canvas.width = pwidth * cwid
            canvas.height = pwidth * chei
            const ctx = canvas.getContext('2d')
            const grid = []
            for(let r = 0; r < chei; r++){
                grid[r] = []
                for(let c = 0; c < cwid; c++){
                    grid[r][c] = null
                }
            }
            const ppieces = []
            let cp = 0
                    ppieces.push(JSON.parse(JSON.stringify(pieces[cp % (pieces.length-1)])))
            function updateAndDrawGrid(){
                ctx.clearRect(0,0,canvas.width,canvas.height)
                for(let r = 0; r < chei; r++){
                    grid[r] = []
                    for(let c = 0; c < cwid; c++){
                        grid[r][c] = null
                    }
                }
                let pn = 0
                ppieces.forEach(p=>{
                    for (let i = 0; i < p.shape.length; i+=2) {
                        const x = p.pos.x + p.shape[i]
                        const y = p.pos.y + p.shape[i+1]
                        if(y >= 0 && y < chei && x >= 0 && x < cwid){
                            grid[y][x] = {color:p.color, piece: pn}
                        }
                    }
                    pn++
                })
                for(let r = 0; r < chei; r++){
                    for(let c = 0; c < cwid; c++){
                        if(grid[r][c]){
                            ctx.fillStyle = grid[r][c].color
                            ctx.fillRect(c*pwidth,r*pwidth,pwidth,pwidth)
                            ctx.strokeRect(c*pwidth,r*pwidth,pwidth,pwidth)
                        } else {
                            ctx.strokeStyle = 'lightgrey'
                            ctx.strokeRect(c*pwidth,r*pwidth,pwidth,pwidth)
                        }
                    }
                }
            }
            function splitPieceIfNeeded(pi){
                try{
                    const p = ppieces[pi];
                    const blocks = [];
                    for (let i = 0; i < p.shape.length; i += 2) {
                        blocks.push({ x: p.pos.x + p.shape[i], y: p.pos.y + p.shape[i + 1] });
                    }
                    const visited = new Set();
                    const groups = [];
                    function dfs(block, group) {
                        const key = `${block.x},${block.y}`;
                        if (visited.has(key)) return;
                        visited.add(key);
                        group.push(block);
                        const directions = [
                            { x: 1, y: 0 },
                            { x: -1, y: 0 },
                            { x: 0, y: 1 },
                            { x: 0, y: -1 }
                        ];
                        for (const dir of directions) {
                            const neighbor = { x: block.x + dir.x, y: block.y + dir.y };
                            if (blocks.some(b => b.x === neighbor.x && b.y === neighbor.y)) {
                                dfs(neighbor, group);
                            }
                        }
                    }
                    for (const block of blocks) {
                        const key = `${block.x},${block.y}`;
                        if (!visited.has(key)) {
                            const group = [];
                            dfs(block, group);
                            groups.push(group);
                        }
                    }
                    if (groups.length > 1) {
                    ppieces.splice(pi, 1);
                    for (const group of groups) {
                        const newShape = [];
                        const baseX = group[0].x - p.pos.x;
                        const baseY = group[0].y - p.pos.y;
                        for (const block of group) {
                            newShape.push(block.x - p.pos.x);
                            newShape.push(block.y - p.pos.y);
                        }
                        ppieces.push({
                            shape: newShape,
                            color: p.color,
                            pos: { x: p.pos.x, y: p.pos.y },
                            center: { x: p.center.x, y: p.center.y }
                        });
                    }
                }
                }catch(e){alert(e)}
            }
            function update(){
                updateAndDrawGrid()
                let pn = 0
                let newpiece = false
                ppieces.forEach(p=>{
                    let hit = false
                    for (let i = 0; i < p.shape.length; i+=2) {
                        const x = p.pos.x + p.shape[i]
                        const y = p.pos.y + p.shape[i+1] + 1
                        if (y >= chei || (grid[y] && (grid[y][x] && grid[y][x].piece !== pn))) {
                            hit = true
                            
                        }
                    }
                    if (!hit){
                        p.pos.y++
                    }
                    if (hit && pn == cp && ppieces[cp].pos.y >= 5){newpiece = true}
                    pn++
                })
                for (let y = 0; y < chei; y++) {
                    let full = true
                    for (let x = 0; x < cwid; x++) {
                        if (!grid[y][x]) full = false
                    }
                    if (full) {
                        // iterate original pieces only (avoid processing newly created pieces this pass)
                        const originalCount = ppieces.length;
                        for (let pi = 0; pi < originalCount; pi++) {
                            const p = ppieces[pi];
                            let deleteqery = []
                            for (let i = 0; i < p.shape.length; i += 2) {
                                if (p.pos.y + p.shape[i + 1] == y) {
                                    deleteqery.push(i)
                                }
                            }
                            for (let i = deleteqery.length - 1; i >= 0; i--) {
                                p.shape.splice(deleteqery[i], 2)
                            }
                            // if we've removed blocks, check whether the piece split
                            splitPieceIfNeeded(pi)
                        }
                    }
                }
                if (newpiece){
                cp++
                    ppieces.push(JSON.parse(JSON.stringify(pieces[cp % (pieces.length-1)])))
                }
                updateAndDrawGrid()
                setTimeout(update,250)
            }
            update()
            function rotate(dir){
                //true for cw
                if (dir){
                    const p = ppieces[cp]
                    const newShape = []
                    for (let i = 0; i < p.shape.length; i+=2) {
                        newShape.push(-p.shape[i+1])
                        newShape.push(p.shape[i])
                    }
                    p.shape = newShape
                    updateAndDrawGrid()
                } else {
                    const p = ppieces[cp]

                    const newShape = []
                    for (let i = 0; i < p.shape.length; i+=2) {
                        newShape.push(p.shape[i+1])
                        newShape.push(-p.shape[i])
                    }
                    p.shape = newShape
                    updateAndDrawGrid()
                }
            }
            //rotate(false)
            addEventListener("keydown", (e)=>{
                switch(e.key){
                    case 'ArrowLeft':
                        if (ppieces[cp].pos.x > 0) ppieces[cp].pos.x--
                        updateAndDrawGrid()
                        break
                    case 'ArrowRight':
                        if (ppieces[cp].pos.x < cwid-1) ppieces[cp].pos.x++
                        updateAndDrawGrid()
                        break
                    case 'r':
                        rotate(false)
                        break
                    case 't':
                        rotate(true)
                        break
                    case 'ArrowDown':
                        //update()
                }
            })
        </script>
    </body>
</html>